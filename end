#include "CytronMakerSumo.h"
const int potPin = A5;  // A5に接続
 
// エッジセンサー閾値
#define EDGE_L_THRESHOLD 150
#define EDGE_R_THRESHOLD 150
 
// 方向の定数
#define LEFT 0
#define RIGHT 1
#define CENTER 2;

int maxSpeed = 200;
 
// 探索方向　searchDirに0が入る
int searchDir = LEFT;
 
// 音符と長さを定義
int melodyPitch[] = { NOTE_E5, NOTE_E5, 0, NOTE_E5, 0, NOTE_C5, NOTE_E5, 0, NOTE_G5 };
int melodyDuration[] = { 10, 10, 10, 10, 10, 10, 10, 10, 10 };  // 10ミリ秒

int seftymelodyPitch[] = {NOTE_E5,NOTE_E5};
int seftymelodyDuration[] = { 10, 10};
int stopmelodyPitch[] = {NOTE_B4,NOTE_B4};
int stopmelodyDuration[] = {10,10};
int potValue = 0;
int str = 0;

int Speed_R = 0;
int Speed_L = 0;
 
void setup() {
  Serial.begin(9600);
  MakerSumo.begin();  //コントローラーの初期化
 
  MakerSumo.playMelody(melodyPitch, melodyDuration, 9);  //(音符, 音符の長さ, 全体の音符の数)

  while(true){
    int cheak = pulseIn(GPIO2, HIGH, 25000); 
    if(cheak < 1100 && cheak > 900){
      MakerSumo.playMelody(seftymelodyPitch, seftymelodyDuration, 2); 
      break;
    }    
  }
 
  // スタートボタンが押されて放されるまで待つ
  while (digitalRead(GPIO1))
    ;
  // ボタンが押されるまで待つ
  // [;]だけのためループ処理なし
  // ボタンが押されていない状態( digitalRead() が HIGH(=1) を返す)の間ループ
  while (!digitalRead(GPIO1))
    ;
  // 押されたら、放されるまで待つ
  // ボタンが押されている状態( digitalRead() が LOW(=0) を返す)の間ループ
 
  // ユーザーLEDをオンにする
  digitalWrite(LED, HIGH);
 
  // スタートルーチンを選択
  potValue = analogRead(potPin);  // 0〜1023の範囲
 
  if (potValue < 600) {
    startRoutine1();
    str = 1;
  } else {
    startRoutine2();
    str = 2;
  }
}
 
 
/*******************************************************************************
  * Main program loop.
  *******************************************************************************/
void loop() {
 //信号受信
  //スタートピンの信号を読み取る(デフォルトの値は０)
  int state = digitalRead(GPIO1);

  if(state == 1){//ゴー！信号を受信したとき
    switch (str) {
    case 1:
      // potValueが0～599
      strategy1();
      break;
    case 2:
      // potValueが600~1023
      strategy2();
      break;
  }
 
  }else{//信号を受信していないとき、もしくはストップ信号を受信したとき
    stopMotor();//モーターを止める
    delay(200);  // チャタリング防止
    return;      // STOP時はここでループ抜け
  }
}
 
 
/*******************************************************************************
  * Strategy.
  *******************************************************************************/
// 作戦1
void strategy1() {
  // 左側のセンサーが白線を検知
  if (analogRead(EDGE_L) < EDGE_L_THRESHOLD) {
    // 後退して右にＵターン
    backoff(RIGHT);
 
    // ^=はXOR演算子 0→1または1→0に変わり敵探索方向を反転
    searchDir ^= 1;
  }
  // 右側のセンサーが白線を検知
  else if (analogRead(EDGE_R) < EDGE_R_THRESHOLD) {
    // 後退して左にＵターン
    backoff(LEFT);
 
    searchDir ^= 1;
  }
  // ノー検知
  else {
    // 相手が検出されるまで検知し続ける　初期値がHIGH
    if ((digitalRead(OPP_FC) == HIGH) && (digitalRead(OPP_FL) == HIGH) && (digitalRead(OPP_FR) == HIGH) && (digitalRead(OPP_L) == HIGH) && (digitalRead(OPP_R) == HIGH)) {
      search(searchDir);
    }
    // 相手を視界に捉えたら攻撃する
    else {
      attack1();
    }
  }
 
  //選手セーフティ(プロポ操作で緊急停止)
  //プロポ受信機の信号を読み取る(0~2000、バインド済みで操作がなければ1500前後になる)
  unsigned long duration = pulseIn(GPIO2, HIGH, 25000);
 
  if (duration > 1750) {  //緊急停止時
    while (true) {        //無限ループ
      stopMotor();       //モーターを止める
      MakerSumo.playMelody(stopmelodyPitch, stopmelodyDuration, 2); 
    }
  }
}
 
// 作戦2
void strategy2() {
  // 左側のセンサーが白線を検知
  if (analogRead(EDGE_L) < EDGE_L_THRESHOLD) {
    // 少し下がる
    seftySetMoterSpeed(MOTOR_L, -100);
    seftySetMoterSpeed(MOTOR_R, -100);
    delay(50);
 
    // 90度右に曲がる
    seftySetMoterSpeed(MOTOR_L, 0);
    seftySetMoterSpeed(MOTOR_R, -255);
    delay(100);
 
  }
  // 右側のセンサーが白線を検知
  else if (analogRead(EDGE_R) < EDGE_R_THRESHOLD) {
    // 少し下がる
    seftySetMoterSpeed(MOTOR_L, -100);
    seftySetMoterSpeed(MOTOR_R, -100);
    delay(50);
 
    // 90度左に曲がる
    seftySetMoterSpeed(MOTOR_L, -255);
    seftySetMoterSpeed(MOTOR_R, 0);
    delay(100);
  }
  // ノー検知
  else {
    // 相手が検出されるまで検知し続ける、初期値がHIGH
    if ((digitalRead(OPP_FC) == HIGH) && (digitalRead(OPP_FL) == HIGH) && (digitalRead(OPP_FR) == HIGH) && (digitalRead(OPP_L) == HIGH) && (digitalRead(OPP_R) == HIGH)) {
      // Go straight.
      seftySetMoterSpeed(MOTOR_L, 70);
      seftySetMoterSpeed(MOTOR_R, 70);
      delay(80);
    }
    // 相手を視界に捉えたら攻撃する
    else {
      attack2();
    }
  }
 
  //選手セーフティ(プロポ操作で緊急停止)
  //プロポ受信機の信号を読み取る(0~2000、バインド済みで操作がなければ1500前後になる)
  unsigned long duration = pulseIn(GPIO2, HIGH, 25000);
 
  if (duration > 1750) {  //緊急停止時
    while (true) {        //無限ループ
      stopMotor();       //モーターを止める
    }
  }
}
 
 
/*******************************************************************************
  * Start Routine
  * This function should be called once only when the game start.
  * ゲーム開始時に一度だけ呼び出される
  *******************************************************************************/
void startRoutine1() {

  // 45度右に曲がる
  seftySetMoterSpeed(MOTOR_L, 255);
  seftySetMoterSpeed(MOTOR_R, 0);
  delay(50);
 
  // Go straight.
  seftySetMoterSpeed(MOTOR_L, 250);
  seftySetMoterSpeed(MOTOR_R, 255);
  delay(80);
 
  // 相手が検出されるまで左に曲がります。
  seftySetMoterSpeed(MOTOR_L, 0);
  seftySetMoterSpeed(MOTOR_R, 255);
  delay(100);
 
  // スケッチが動き始めてからの経過時間(millis＝ミリ秒)をstartTimestampに入れる
  unsigned long startTimestamp = millis();
  while (digitalRead(OPP_FC)) {
    // タイムアウト(0.1秒)後に相手が見つからない場合終了する
    // startTimestampー現在時刻(millis)からこのループが始まってからの経過時間を計算
    if (millis() - startTimestamp > 100) {
      stopMotor();
      break;
    }
  }
}
 
void startRoutine2() {
  // 開始遅延　1000ミリ秒＝1秒
  delay(5000);
 
  // 45度左に曲がる
  seftySetMoterSpeed(MOTOR_L, 0);
  seftySetMoterSpeed(MOTOR_R, 255);
  delay(50);
 
  // Go straight.
  seftySetMoterSpeed(MOTOR_L, 250);
  seftySetMoterSpeed(MOTOR_R, 255);
  delay(80);
 
  // 相手が検出されるまで右に曲がります。
  seftySetMoterSpeed(MOTOR_L, 255);
  seftySetMoterSpeed(MOTOR_R, 0);
  delay(100);
 
  // スケッチが動き始めてからの経過時間(millis＝ミリ秒)をstartTimestampに入れる
  unsigned long startTimestamp = millis();
  while (digitalRead(OPP_FC)) {
    // タイムアウト(0.1秒)後に相手が見つからない場合終了する
    // startTimestampー現在時刻(millis)からこのループが始まってからの経過時間を計算
    if (millis() - startTimestamp > 100) {
      stopMotor();
      break;
    }
  }
}
 
 
/*******************************************************************************
  * Search
  *******************************************************************************/
void search(int dir) {
  //  円を描くように動く　引数(dir)によって左回りか右回りか決まる
  if (dir == LEFT) {
    seftySetMoterSpeed(MOTOR_L, 100);
    seftySetMoterSpeed(MOTOR_R, 120);
  } else {
    seftySetMoterSpeed(MOTOR_L, 120);
    seftySetMoterSpeed(MOTOR_R, 100);
  }
}
 
 
/*******************************************************************************
  * Attack
  * Track and attack the opponent in full speed.
  * Do nothing if opponent is not found.
  * 相手が見つからない場合は何もしない
  *******************************************************************************/
void attack1() {
  // Opponent in front center.
  // Go straight in full speed.
  if (digitalRead(OPP_FC) == LOW) {
    seftySetMoterSpeed(MOTOR_L, 255);
    seftySetMoterSpeed(MOTOR_R, 255);
  }
 
  // Opponent in front left.
  // Turn left.
  else if (digitalRead(OPP_FL) == LOW) {
    seftySetMoterSpeed(MOTOR_L, 0);
    seftySetMoterSpeed(MOTOR_R, 180);
  }
 
  // Opponent in front right.
  // Turn right.
  else if (digitalRead(OPP_FR) == LOW) {
    seftySetMoterSpeed(MOTOR_L, 180);
    seftySetMoterSpeed(MOTOR_R, 0);
  }
 
  // Opponent in left.
  // Turn left.
  else if (digitalRead(OPP_L) == LOW) {
    seftySetMoterSpeed(MOTOR_L, -100);
    seftySetMoterSpeed(MOTOR_R, 100);
    delay(300);
  }
 
  // Opponent in right.
  // Turn right.
  else if (digitalRead(OPP_R) == LOW) {
    seftySetMoterSpeed(MOTOR_L, 100);
    seftySetMoterSpeed(MOTOR_R, -100);
    delay(300);
  }
}
 
void attack2() {
  // Opponent in front center.
  // Go straight in full speed.
  if (digitalRead(OPP_FC) == LOW) {
    if (digitalRead(OPP_FL) == LOW) {
      seftySetMoterSpeed(MOTOR_L, 255);
      seftySetMoterSpeed(MOTOR_R, 0);
      delay(300);
 
      seftySetMoterSpeed(MOTOR_L, 50);
      seftySetMoterSpeed(MOTOR_R, 255);
      delay(300);
 
      seftySetMoterSpeed(MOTOR_L, 255);
      seftySetMoterSpeed(MOTOR_R, 255);
    }
   
    else if (digitalRead(OPP_FR) == LOW) {
      seftySetMoterSpeed(MOTOR_L, 0);
      seftySetMoterSpeed(MOTOR_R, 255);
      delay(300);
 
      seftySetMoterSpeed(MOTOR_L, 255);
      seftySetMoterSpeed(MOTOR_R, 50);
      delay(300);
 
      seftySetMoterSpeed(MOTOR_L, 255);
      seftySetMoterSpeed(MOTOR_R, 255);
    }

     else{
      seftySetMoterSpeed(MOTOR_L, 255);
      seftySetMoterSpeed(MOTOR_R, 255);
    }
  }
 
  // Opponent in front left.
  // Turn left.
  else if (digitalRead(OPP_FL) == LOW) {
    seftySetMoterSpeed(MOTOR_L, 0);
    seftySetMoterSpeed(MOTOR_R, 255);
  }
 
  // Opponent in front right.
  // Turn right.
  else if (digitalRead(OPP_FR) == LOW) {
    seftySetMoterSpeed(MOTOR_L, 255);
    seftySetMoterSpeed(MOTOR_R, 0);
  }
 
  // Opponent in left.
  // Turn left.
  else if (digitalRead(OPP_L) == LOW) {
    seftySetMoterSpeed(MOTOR_L, -100);
    seftySetMoterSpeed(MOTOR_R, 100);
    delay(300);
  }
 
  // Opponent in right.
  // Turn right.
  else if (digitalRead(OPP_R) == LOW) {
    seftySetMoterSpeed(MOTOR_L, 100);
    seftySetMoterSpeed(MOTOR_R, -100);
    delay(300);
  }
}
 
 
/*******************************************************************************
  * Back Off
  * This function should be called when the ring edge is detected.
  * 白線検知の際に呼び出される
  *******************************************************************************/
void backoff(int dir) {
  // Reverse
  seftySetMoterSpeed(MOTOR_L, -100);
  seftySetMoterSpeed(MOTOR_R, -100);
  delay(100);
 
  // Rotate..
 
  if (dir == LEFT) {
    // Rotate left backward.
    seftySetMoterSpeed(MOTOR_L, -70);
    seftySetMoterSpeed(MOTOR_R, 70);
  } else if (dir == RIGHT) {
    // Rotate right backward.
    seftySetMoterSpeed(MOTOR_L, 70);
    seftySetMoterSpeed(MOTOR_R, -70);
  }
  delay(220);
 
  // Stop the motors.
  stopMotor();
}
 
/*******************************************************************************
  * Stop　motors
  *******************************************************************************/
//モータースピード設定 基盤炎上対策として最大出力を180にする
void seftySetMoterSpeed(int LR,int speed){//左右を判断する変数LRにはMOTOR_L,MOTOR_Rを入れて
  if(speed > maxSpeed){//もしも180を超えるスピードを設定されても
    speed = maxSpeed;  //強制的に180にする
  }
  MakerSumo.setMotorSpeed(LR,speed);//モーターを回す
  //現在のスピードを記録
  if(LR == MOTOR_R){
    Speed_R = speed;
  }else{
    Speed_L = speed;
  }
}
//停止
void stopMotor(){
  int L = Speed_L - (Speed_L/6);
  int R = Speed_R - (Speed_R/6);
  for(int i = 0;i <6; i++){
    seftySetMoterSpeed(MOTOR_L,Speed_L);
    seftySetMoterSpeed(MOTOR_R,Speed_R);
    delay(20);
  }
    seftySetMoterSpeed(MOTOR_L,0);
    seftySetMoterSpeed(MOTOR_R,0);
  
}
